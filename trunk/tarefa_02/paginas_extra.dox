/**
 *
 * 
@mainpage Autores

	@li Nome: Fernando Lucchesi Bastos Jurema RA: 091187
	@li Nome: Gabriel Coutinho Natucci        RA: 091247

@page page0 Introdução

O projeto desenvolvido tem por base mensurar e implementar diferentes tipos de IO, e verificar seu impacto quanto
ao tempo de acesso e execução.\ Para este experimento foi implementado várias formas de copiar arquivos para outros
arquivos (diretórios).\ Após essa implementação, mensura-se o tempo para cada uma, rodando várias vezes o programa
para um mesmo arquivo, e confrontam-se essas estatísticas de cada implementação com o comando cp nativo dos sistemas Unix. 


@page page1 Decisões de Projeto

Como forma de implementar as diferentes opções de IO, optamos por criar 4 funções diferentes, que serão chamadas por linha
de comando na forma ./mycp [nome_do_arquivo] [nome_do_destino] [função].
Caso o parâmetro [função] não seja passado, o programa utiliza a implementação padrão da função mycp1().

Para medirmos o tempo de cada execução, usamos o comando time. Para limpar o cache após cada execução, executamos drop_cache,
conforme definido na especificação do trabalho.

Afim de facilitar a obtenção de várias medidas de tempo, optamos por escrever um script (testar.sh) que irá executar o comando várias
vezes, para melhorar as estatísticas de tempo.

Optamos por usar um makefile para compilar, depurar e gerar a documentação do programa.
	@li Compilar: make
	@li Depurar: make test
	@li Documentação: make doc
	@li Testar leaks de memória: make mem

O comando "make doc" gera uma documentação em html e em latex (que depois é convertida em
um relatório -este- em pdf) com a ajuda da ferramenta Doxygen, na pasta doc.


Na função mycp1() foi utilizada a implementação mais simples de read() e write() com I/O bloqueante.
Essa função simplesmente abre um arquivo de leitura, executa um chdir() e depois abre o arquivo de escrita,
escrevendo continuamente (loop) em blocos de 4kb.

Na função mycp2() foi utilizada a implementação com I/O não bloqueante.
Essa função implementa as funções set_fl() e clr_fl(), que setam/cancelam o I/O como sendo não bloqueante
através da utilização da opção O_NONBLOCK, executando um loop como mycp1().

Na função mycp3() foi utilizada a implementação com a utilização de select(), que verifica a disponibilidade
de descritores de arquivos previamente setados para serem observados (um para leitura e outro para escrita),
para que alguma operação de I/O possa ser executada. Observou-se um desempenho menor (tempo de execução maior)
nesta função em relação às demais.

Na função mycp4() foi utilizada o conceito de mmaps (Memory-Mapped I/O), de forma que lê-se o arquivo em um único
comando, sabendo previamente o seu tamanho através da função fstat().
Por não haverem loops na sua execução, nem o comando read() - potencialmente bloqueável - esta função apresentou um
desempenho ligeiramente melhor que as demais.


@page page2 Dificuldades

As principais dificuldades enfrentadas no trabalho foi a definição e implementação eficiente de uma função mycp4()
com desempenho melhor (na média) do que as demais. Inicialmente pensou-se em uma implementação de I/O assíncrono,
utilizando a biblioteca aio.h e a função aio_read() e aio_write(). Porém, foi difícil implementá-la com exatidão, uma 
vez que a documentação sobre as funções era pouco clara, e a implementação nunca copiava os arquivos de forma correta
(geralmente copiava-se apenas um bloco de 4kb, mesmo executando-se a operação em loop).


Dessa forma, por razões de facilidade de implementação, utilizou-se a biblioteca mmap.h, e as funções mmap() e memcpy(),
evitando assim um loop na execução e melhorando o desempenho geral da função.



@page page3 Estrutura do Código

O código foi dividido em 4 arquivos principais: um arquivo .h (mycp.h), contendo as definições das funções e bibliotecas utilizadas,
e cinco arquivos . c (mycp.c, mycp1.c, mycp2.c, mycp3.c, mycp4.c).

O tamanho da blocagem utilizados para as operações de leitura está definido em mycp.h : MAXBUFF.

Cada arquivo mycp*.c contém uma única função que implementa alguma opção de cópia/escrita de arquivos, seja por meio de loops de escrita,
usando I/O não bloqueante, select() ou mmap().

Para maiores informações, verifique a estrutura dos arquivos na página Doxygen correspondente.

@page page4 Análise Estatística
 * 
 * 
 */
